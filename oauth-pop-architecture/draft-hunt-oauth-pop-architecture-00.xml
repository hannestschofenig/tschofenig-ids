<?xml version='1.0' encoding='UTF-8' ?>
<!DOCTYPE rfc SYSTEM 'rfc2629.dtd'>
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>

<rfc category='info' ipr='trust200902' docName='draft-hunt-oauth-pop-architecture-00.txt'>
	<?rfc strict='no' ?>
	<?rfc toc='yes' ?>
	<?rfc tocdepth='3' ?>
	<?rfc symrefs='yes' ?>
	<?rfc sortrefs='yes' ?>
	<?rfc compact='no' ?>
	<?rfc subcompact='no' ?>
	<front>

		<title abbrev="OAuth 2.0 PoP Architecture">OAuth 2.0 Proof-of-Possession (PoP) Security Architecture</title>

		<author role="editor" fullname="Phil Hunt" initials="P." surname="Hunt">
			<organization>Oracle Corporation</organization>
			<address>
				<postal>
					<street></street>
					<city></city>
					<code></code>
					<country></country>
				</postal>
				<phone></phone>
				<email>phil.hunt@yahoo.com</email>
			</address>
		</author>

		<author fullname="Justin Richer" initials="J." surname="Richer">
			<organization>The MITRE Corporation</organization>

			<address>
				<postal>
					<street></street>

					<city></city>

					<region></region>

					<code></code>

					<country></country>
				</postal>
				<email>jricher@mitre.org</email>
			</address>
		</author>

		<author fullname="William Mills" initials="W." surname="Mills">
			<organization>Yahoo! Inc.</organization>
			<address>
				<postal>
					<street></street>
					<city></city>
					<code></code>
					<country></country>
				</postal>
				<phone></phone>

				<email>wmills@yahoo-inc.com </email>
			</address>
		</author>


		<author fullname="Prateek Mishra" initials="P." surname="Mishra">
			<organization>Oracle Corporation</organization>
			<address>
				<postal>
					<street></street>
					<city></city>
					<code></code>
					<country></country>
				</postal>
				<phone></phone>
				<email>prateek.mishra@oracle.com</email>
			</address>
		</author>


		<author initials="H." surname="Tschofenig" fullname="Hannes Tschofenig">
			<organization>ARM Limited</organization>
			<address>
				<postal>
					<street></street>
					<city></city>
					<code></code>
					<country>Austria</country>
				</postal>
				<phone></phone>
				<email>Hannes.Tschofenig@gmx.net</email>
				<uri>http://www.tschofenig.priv.at</uri>
			</address>
		</author>

		<date year='2014'/>
		<area>Security</area>
		<workgroup>OAuth</workgroup>
		<keyword>Internet-Draft</keyword>

		<abstract>
			<t>The OAuth 2.0 bearer token specification, as defined in RFC 6750, allows any party in
   possession of a bearer token (a "bearer") to get access to
   the associated resources (without demonstrating possession of a
   cryptographic key).  To prevent misuse, bearer tokens must to be
   protected from disclosure in transit and at rest.</t>

			<t>Some scenarios demand additional security protection whereby a client needs to demonstrate possession of cryptographic keying material when accessing a protected resource. This document motivates the development of the OAuth 2.0 proof-of-possession security mechanism. </t>
		</abstract>
	</front>
	<middle>

		<!-- ////////////////////////////////////////////////////////////////////////////////// -->

		<section title='Introduction'>

			<t>At the time of writing the OAuth 2.0 protocol family (<xref target="RFC6749"/>, <xref target="RFC6750"/>, and <xref target="RFC6819"/>) offer a single standardized security mechanism to  access protected resources, namely the bearer token. RFC 6750 <xref target="RFC6750"/> specifies the bearer token mechanism and defines it as follows: 

				<list style="empty"> 
					<t>"A security token with the property that any party in possession of
      the token (a "bearer") can use the token in any way that any other
      party in possession of it can.  Using a bearer token does not
      require a bearer to prove possession of cryptographic key material."</t>
				</list> 
			</t> 

			<t>The bearer token meets the security needs of a number of use cases the OAuth 2.0 protocol had originally been designed for. There are, however, other scenarios that require stronger security properties and ask for active participation of the OAuth client in form of cryptographic computations when presenting an access token to a resource server. 
			</t> 

			<t>This document outlines additional use cases requiring stronger security protection in <xref target="use-cases"/>, identifies threats in <xref target="threats"/>, proposes different ways to mitigate those threats in <xref target="threat-mitigation"/>, outlines an architecture for a solution that builds on top of the existing OAuth 2.0 framework in <xref target="architecture"/>, and concludes with a requirements list in <xref target="requirements"/>.</t>

		</section>

		<!-- ////////////////////////////////////////////////////////////////////////////////// -->

		<section title='Terminology'>
			<t>
          The key words 'MUST', 'MUST NOT', 'REQUIRED', 'SHALL', 'SHALL NOT', 'SHOULD',
          'SHOULD NOT', 'RECOMMENDED', 'MAY', and 'OPTIONAL' in this specification are to be
          interpreted as described in <xref target='RFC2119' />,
   with the important qualification that, unless otherwise stated, these
   terms apply to the design of the protocol, not its
   implementation or application.
			</t>

		</section>

		<!-- ////////////////////////////////////////////////////////////////////////////////// -->

		<section anchor="use-cases" title="Use Cases">
			<t>The main use case that motivates better-than-bearer token security is the desire of resource servers to obtain additional assurance that the client is indeed authorized to present this access token. The expectation is that the use of additional credentials (symmetric or asymmetric keying material) will encourage developers to take additional precautions when transferring or storing the access token in combination with these credentials.</t> 

			<t>Additional use cases listed below provide further requirements for the solution development.</t>

			<section title="Access to an 'Unprotected' Resource">
				<t>This use case is for a web client that needs to access
          a resource that makes data available (such as videos) without offering integrity and confidentiality
          protection using TLS. Still, the initial resource request using OAuth, which includes the access token, must be protected
          against various threats (e.g., token replay, token modification).</t>
				<t>While it is possible to utilize bearer tokens in this scenario with TLS 
		  protection when the request to the protected resource is made, as described in  <xref target="RFC6750"/>, there may be the desire to avoid using TLS between the 
		  client and the resource server at all. In such a case the bearer token approach is not possible since it relies on TLS 
		  for ensuring integrity and confidentiality protection of the access token exchange since otherwise replay attacks
		  are possible: First, an eavesdropper may steal an access token and
		  represent it at a different resource server. Second, an eavesdropper may 
		  steal an access token and replay it against the same resource server at a 
		  later point in time. In both cases, if the attack is successful, the 
		  adversary gets access to the resource owners data or may perform an 
		  operation selected by the adversary (e.g., sending a message). Note that 
		  the adversary may obtain the access token (if the recommendations in <xref target="RFC6749"/> and <xref target="RFC6750"/> are not followed) using a number of ways, including 
		  eavesdropping the communication on the wireless link.
				</t>
				<t>Consequently, the important assumption in this use case is that a resource server does not have TLS support and the security solution should work in such a scenario.
         Furthermore, it may not be necessary to provide authentication of the resource server towards the client.</t>
			</section>

			<section title="Offering Application Layer End-to-End Security">

				<t>In Web deployments resource servers are often placed
          behind load balancers, which are deployed by the same organization that operates the resource servers. 
		  These load balancers may terminate the TLS connection setup
           and HTTP
          traffic is transmitted in the clear from the load
          balancer to the resource server. With application layer security 
		  independent of the underlying TLS security it is possible to allow
		  application servers to perform cryptographic verification on an end-to-end basis.</t>


				<t>The key aspect in this use case is therefore to offer end-to-end
          security in the presence of load balancers
          via application layer security.</t>

			</section>

			<section title="Preventing Access Token Re-Use by the Resource Server">

				<t>Imagine a scenario where a resource server that receives a valid access token re-uses it with other 
				resource server. The reason for re-use may be malicious or may well be legitimate. In a legitimate use case 
				consider chaining of computations whereby a resource server needs to consult other third party resource servers to complete the 
				requested operation. In both cases it may be assumed that the scope of the access token is sufficiently
				large that it allows such a re-use. For example, imagine a case where a company operates email services 
				as well as picture sharing services and that company had decided to issue access tokens with a scope 
				that allows access to both services.</t>

				<t>With this use case the desire is to prevent such access token re-use. This also implies that 
				the legitimate use cases require additional enhancements for request chaining.</t>

			</section>

			<section title="TLS Channel Binding Support">

				<t>In this use case we consider the scenario where an OAuth 2.0 request to a protected resource is secured using 
			  TLS but the client and the resource server demand that the underlying TLS exchange is bound to additional application 
			  layer security to prevent cases where the TLS connection is terminated at a TLS intermediary, which
			  splits the TLS connection into two separate connections.</t>

				<t>In this use case additional information is conveyed to the resource server to ensure that no entity entity has 
			  tampered with the TLS connection.</t>
			</section>

		</section>


		<!-- ////////////////////////////////////////////////////////////////////////////////// -->


		<section anchor="threats" title="Security and Privacy Threats">

			<t>The following list presents several common threats against protocols utilizing some form of tokens. This list of threats is based on NIST Special Publication 800-63 <xref target="NIST800-63"/>. We exclude a discussion of threats related to any form of identity proofing and authentication of the resource owner to the authorization server since these procedures are not part of the OAuth 2.0 protocol specification itself.</t>
			<t><list style="hanging">
					<t hangText="Token manufacture/modification:"><vspace blankLines="1"/> An attacker may generate a bogus tokens or modify the token content (such as  authentication or attribute statements) of an existing token, causing resource server to grant inappropriate access to the client. For example, an attacker may modify the token to extend the validity period. A client may modify the token to have access to information that they should not be able to view.</t>
					<t hangText="Token disclosure:">Tokens may contain personal data, such as real name, age or birthday, payment information, etc.</t>
					<!--    <t hangText="Token repudiation:">A token may be repudiated if the proper mechanisms are not in place.</t> -->
					<t hangText="Token redirect:"><vspace blankLines="1"/>An attacker uses the token generated for consumption by the resource server to obtain access to another resource server.</t>
					<t hangText="Token reuse:"><vspace blankLines="1"/> An attacker attempts to use a token that has already been used once with a resource server. The attacker may be an eavesdropper who observes the communication exchange or, worse, one of the communication end points. A client may, for example, leak access tokens because it cannot keep secrets confidential. A client may also re-use access tokens for some other resource servers. Finally, a resource server may use a token it had obtained from a client and use it with another resource server that the client interacts with. A resource server, offering relatively unimportant application services, may attempt to use an access token obtained from a client to access a high-value service, such as a payment service, on behalf of the client using the same access token.</t>
				</list> 
			</t>
			<t>We excluded one threat from the list, namely 'token repudiation'. Token repudiation refers to a property whereby a resource server is given an assurance that the authorization server cannot deny to have created a token for the Client. We believe that such a property is interesting but most deployments prefer to deal with the violation of this security property through business actions rather than by using cryptography.</t>

		</section> 


		<!-- ////////////////////////////////////////////////////////////////////////////////// -->

		<section anchor="threat-mitigation" title="Threat Mitigation"> 

			<t>A large range of threats can be mitigated by protecting the content of the token, for example using a digital signature or a keyed message digest. Alternatively, the content of the token could be passed by reference rather than by value (requiring a separate message exchange to resolve the reference to the token content). To simplify the subsequent description we assume that the token itself is digitally signed by the authorization server and therefore cannot be modified. <!-- This also provides the basis for non-repudiation.--> </t>

			<t>To deal with token redirect it is important for the authorization server to include the identifier of the intended recipient - the resource server. A resource server must not be allowed to accept access tokens that are not meant for its consumption. </t>

			<t>To provide protection against token disclosure two approaches are possible, namely (a) not to include sensitive information inside the token or (b) to ensure confidentiality protection. The latter approach requires at least the communication interaction between the client and the authorization server as well as the interaction between the client and the resource server to experience confidentiality protection. As an example, TLS with a ciphersuite that offers confidentiality protection has to be applied (which is currently true for all ciphersuites, except for one). Encrypting the token content itself is another alternative. In our scenario the authorization server would, for example, encrypt the token content with a symmetric key shared with the resource server.  
			</t>

			<t>To deal with token reuse more choices are available.</t>

			<section anchor="confidentiality" title="Confidentiality Protection">

				<t>In this approach confidentiality protection of the exchange is provided on the communication interfaces between the client and the resource server, and between the client and the authorization server. No eavesdropper on the wire is able to observe the token exchange. Consequently, a replay by a third party is not possible. An authorization server wants to ensure that it only hands out tokens to clients it has authenticated first and who are authorized. For this purpose, authentication of the client to the authorization server will be a requirement to ensure adequate protection against a range of attacks. This is, however, true for the description in <xref target="intended"/> and <xref target="confirmation"/> as well. Furthermore, the client has to make sure it does not distribute (or leak) the access token to entities other than the intended the resource server. For that purpose the client will have to authenticate the resource server before transmitting the access token.
				</t>

			</section> 

			<section anchor="intended" title="Sender Constraint">

				<t>Instead of providing confidentiality protection the authorization server could also put the identifier of the client into the protected token with the following semantic: 'This token is only valid when presented by a client with the following identifier.' When the access token is then presented to the resource server how does it know that it was provided by the client? It has to authenticate the client! There are many choices for authenticating the client to the resource server, for example by using client certificates in TLS <xref target="RFC5246"/>, or pre-shared secrets within TLS <xref target="RFC4279"/>. The choice of the preferred authentication mechanism and credential type may depend on a number of factors, including <list style="symbols"> 
						<t>security properties</t>
						<t>available infrastructure</t>
						<t>library support</t>
						<t>credential cost (financial)</t>
						<t>performance</t>
						<t>integration into the existing IT infrastructure</t>
						<t>operational overhead for configuration and distribution of credentials</t>
					</list> 
				</t>
				<t>This long list hints to the challenge of selecting at least one mandatory-to-implement client authentication mechanism.</t>

			</section>

			<section anchor="confirmation" title="Key Confirmation">

				<t>A variation of the mechanism of sender authentication, described in <xref target="intended"/>, is to replace authentication with the proof-of-possession of a specific (session) key, i.e., key confirmation. In this model the resource server would not authenticate the client itself but would rather verify whether the client knows the session key associated with a specific access token. Examples of this approach can be found with the OAuth 1.0 MAC token <xref target="RFC5849"/>, and Kerberos <xref target="RFC4120"/> when utilizing the AP_REQ/AP_REP exchange (see also <xref target="I-D.hardjono-oauth-kerberos"/> for a comparison between Kerberos and OAuth).</t>

				<t>To illustrate key confirmation the first examples borrow from Kerberos and use symmetric key cryptography. Assume that the authorization server shares a long-term secret with the resource server, called K(Authorization Server-Resource Server). This secret would be established between them out-of-band. When the client requests an access token the authorization server creates a fresh and unique session key Ks and places it into the token encrypted with the long term key K(Authorization Server-Resource Server). Additionally, the authorization server attaches Ks to the response message to the client (in addition to the access token itself) over a confidentiality protected channel. When the client sends a request to the resource server it has to use Ks to compute a keyed message digest for the request (in whatever form or whatever layer). The resource server, when receiving the message, retrieves the access token, verifies it and extracts K(Authorization Server-Resource Server) to obtain Ks. This key Ks is then used to verify the keyed message digest of the request message.  
				</t>

				<t>Note that in this example one could imagine that the mechanism to protect the token itself is based on a symmetric key based mechanism to avoid any form of public key infrastructure but this aspect is not further elaborated in the scenario.</t>

				<t>A similar mechanism can also be designed using asymmetric cryptography. When the client requests an access token the authorization server creates an ephemeral public / privacy key pair (PK/SK) and places the public key PK into the protected token. When the authorization server returns the access token to the client it also provides the PK/SK key pair over a confidentiality protected channel. When the client sends a request to the resource server it has to use the privacy key SK to sign the request. The Resource Server, when receiving the message, retrieves the access token, verifies it and extracts the public key PK. It uses this ephemeral public key to verify the attached signature.</t>
			</section> 


			<section title="Summary">

				<t> As a high level message, there are various ways how the threats can be mitigated and while the details of each solution is somewhat different they all ultimately accomplish the goal. </t>

				<t>The three approaches are: <list style="hanging">

						<t hangText="Confidentiality Protection:"><vspace blankLines="1"/>The weak point with this approach, which is briefly described in <xref target="confidentiality"/>, is that the Client has to be careful to whom it discloses the access token. What can be done with the token entirely depends on what rights the token entitles the presenter and what constraints it contains. A token could encode the identifier of the Client but there are scenarios where the Client is not authenticated to the Resource Server or where the identifier of the Client rather represents an application class rather than a single application instance. As such, it is possible that certain deployments choose a rather liberal approach to security and that everyone who is in possession of the access token is granted access to the data. 
							<!-- <vspace blankLines="1"/> 
   Furthermore, to secure the access token at rest; unauthorized disclosure could be harmful particularly when the token has a rather long lifetime. Intuitively, one would argue that access tokens are easy to mint and used for a small time duration only to reduce the risk of exposure.--> </t>

						<t hangText="Sender Constraint:"><vspace blankLines="1"/>The weak point with this approach, which is briefly described in <xref target="intended"/>, is to setup the authentication infrastructure such that Clients can be authenticated towards Resource Servers. Additionally, Authorization Server must encode the identifier of the Client in the token for later verification by the Resource Server. Depending on the chosen layer for providing Client-side authentication there may be additional challenges due Web server load balancing, lack of API access to identity information, etc. 
						</t>
						<t hangText="Key Confirmation:"><vspace blankLines="1"/>The weak point with this approach, see <xref target="confirmation"/>, is the increased complexity: a complete key distribution protocol has to be defined.  
						</t>
					</list> 
				</t>

				<t>In all cases above it has to be ensured that the Client is able to keep the credentials secret.</t> 

			</section>

		</section>


		<!-- ////////////////////////////////////////////////////////////////////////////////// -->

		<section anchor="architecture" title="Architecture"> 

			<t>The proof-of-possession security concept assumes that the authorization server acts as a trusted third party that bind a keys to access tokens. These keys are then used by the client to demonstrate the possession of the secret to the resource server when accessing the resource. The resource server, when receiving an access token, needs to verify that the key used by the client matches the one included in the access token.</t>
			
		<t>There are slight differences between the use of symmetric keys and asymmetric keys when they are bound to the access token and the subsequent interaction between the client and the authorization server when demonstrating possession of these keys. <xref target="arch-symm"/> shows the symmetric key procedure and <xref target="arch-asymm"/> illustrates how asymmetric keys are used. </t>
			
			   <t>With the JSON Web Token (JWT) a standardized format for access tokens is available. The necessary elements to bind symmetric or asymmetric keys to the JWT is described in <xref target="I-D.jones-oauth-proof-of-possession"/>.</t>
			
			<t>
				<figure anchor="arch-symm" title="Interaction between the Client and the Authorization Server (Symmetric Keys).">
					<artwork>
						<![CDATA[
                     +---------------+
                    ^|               |  
                  // | Authorization |  
                 /   | Server        |          
               //    |               |        
              /      |               |        
       (I)  //      /+---------------+        
Access     /      //                          
Token     /      /                            
Request //     //  (II) Access Token          
+Params /      /        +Symmetric Key       
     //     //                                
    /      v                                  
  +-----------+                       +------------+
  |           |                       |            |
  |           |                       | Resource   |
  | Client    |                       | Server     |
  |           |                       |            |
  |           |                       |            |
  +-----------+                       +------------+
]]>
					</artwork>
				</figure>
			</t>

			<t>In order to request an access token the client interacts with the authorization server as part of the a normal grant exchange, as shown in <xref target="arch-symm"/>. However, it needs to include additional information elements for use with the PoP security mechanism, as depicted in message (I). In message (II) the authorization server then returns the requested access token. In addition to the access token itself, the symmetric key is communicated to the client. This symmetric key is a unique and fresh session key with sufficient entropy for the given lifetime. Furthermore, information within the access token ties it to this specific symmetric key.</t>
			
			<t>Note: For this security mechanism to work the client as well as the resource server need to gain possession to the session key. While the key transport mechanism from the authorization server to the client has been explained in the previous paragraph there are three ways for communicating this session key from the authorization server to the resource server, namely 
			<list style="itemize">
			<t>Embedding the symmetric key inside the access token itself. This requires that the symmetric key is confidentiality protected.</t>
			<t>The resource server queries the authorization server for the symmetric key. This is an approach envisioned by the token introspection endpoint <xref target="I-D.richer-oauth-introspection"/>.</t>
			<t>The authorization server and the resource server both have access to the same backend database. This is case in smaller, tightly coupled systems.</t>
			</list> 
      </t>
			<t>
				<figure anchor="arch-asymm" title="Interaction between the Client and the Authorization Server (Asymmetric Keys).">
					<artwork>
						<![CDATA[
                     +---------------+
                    ^|               |
Access Token Req. // | Authorization |
+Parameters      /   | Server        |
+[Fingerprint] //    |               |
              /      |               |
    (I)     //      /+---------------+
           /      //
          /      /     (II)
        //     //  Access Token
        /      /   +[ephemeral
     //     //      asymmetric key pair]
    /      v
  +-----------+                       +------------+
  |           |                       |            |
  |           |                       | Resource   |
  | Client    |                       | Server     |
  |           |                       |            |
  |           |                       |            |
  +-----------+                       +------------+
]]>
					</artwork>
				</figure>
			</t>
			
			<t>The use of asymmetric keys is slightly different since the client or the server could be involved in the generation of the ephemeral key pair. This exchange is shown in <xref target="arch-symm"/>. If the client generates the key pair it includes a fingerprint of the public key (of the SubjectPublicKeyInfo structure, more precisely). The authorization server would include this fingerprint in the access token and thereby bind the asymmetric key pair to the token. If the client did not provide a fingerprint in the request then the authorization server is asked to create an ephemeral asymmetric key pair, binds the fingerprint of the public key to the access token, and returns the asymmetric key pair to the client.</t>
			
			<t>Once the client has obtained the necessary access token and keying material it can start to interact with the resource server. To demonstrate possession of the key bound to the access token it  creates the "Authenticator", which is a data structure that binds the request to the access token with the help of the available keying material. When the server receives the request it evaluates it and decides whether access to the protected resource can be granted. This exchange is shown in <xref target="architecture-2"/>.

				<figure anchor="architecture-2" title="Client demonstrates PoP.">
					<artwork>
						<![CDATA[
                   +---------------+
                   |               |
                   | Authorization |
                   | Server        |
                   |               |
                   |               |
                   +---------------+






+-----------+  Authenticator (a)    +------------+
|           |---------------------->|            |
|           |  [+Access Token]      | Resource   |
| Client    |                       | Server     |
|           |  Authenticator (b)    |            |
|           |<----------------------|            |
+-----------+                       +------------+

     ^                                    ^
     |                                    |
     |                                    |
 Symmetric Key                       Symmetric Key
    or                                   or 
 Asymmetric Key Pair                Public Key (Client)
    +                                     +
  Parameters                          Parameters
]]>
					</artwork>
				</figure>
			</t>
			
			<t>The specification describing the Authenticator can be found in TBD.</t>
			

		</section> 

		<!-- ////////////////////////////////////////////////////////////////////////////////// -->

		<section anchor="requirements" title="Requirements"> 

	
			<t>RFC 4962 <xref target="RFC4962"/> gives useful guidelines for designers of authentication and key management protocols. While RFC 4962 was written with the AAA framework used for network access authentication in mind the offered suggestions are useful for the design of other key management systems as well. The following requirements list applies OAuth 2.0 terminology to the requirements outlined in RFC 4962.</t>

			<t>These requirements include 
				<list style="hanging">
					<t hangText="Cryptographic Algorithm Independent:"><vspace blankLines="1"/>  The key management protocol MUST be cryptographic algorithm
         independent.</t>

					<t hangText="Strong, fresh session keys:"><vspace blankLines="1"/> Session keys MUST be
         strong and fresh.  Each session deserves an independent session
         key, i.e., one that is generated specifically
         for the intended use. In context of OAuth this means that keying material is created in such a way that can only be used by the combination of a Client instance, protected resource, and authorization scope.</t>

					<t hangText="Limit Key Scope:"><vspace blankLines="1"/> Following the principle of least privilege, parties MUST NOT
         have access to keying material that is not needed to perform
         their role. Any protocol that is used to establish session keys MUST
         specify the scope for session keys, clearly identifying the
         parties to whom the session key is available.</t>

					<t hangText="Replay Detection Mechanism:"><vspace blankLines="1"/> The key management protocol exchanges MUST be replay
         protected. Replay protection allows a protocol message
         recipient to discard any message that was recorded during a
         previous legitimate dialogue and presented as though it
         belonged to the current dialogue.</t>

					<t hangText="Authenticate All Parties:"><vspace blankLines="1"/> Each party in the key management protocol MUST be
         authenticated to the other parties with whom they communicate.
         Authentication mechanisms MUST maintain the confidentiality of
         any secret values used in the authentication process. Secrets MUST NOT be sent to
         another party without confidentiality protection.</t>

					<t hangText="Authorization:"><vspace blankLines="1"/> Client and Resource Server authorization MUST be performed.  These
         entities MUST demonstrate possession of the appropriate keying
         material, without disclosing it.  Authorization is REQUIRED
         whenever a Client interacts with an Authorization Server.  The
         authorization checking prevents an elevation of privilege
         attack, and it ensures that an unauthorized authorized is
         detected.</t>

					<t hangText="Keying Material Confidentiality and Integrity:"><vspace blankLines="1"/> While preserving algorithm independence, confidentiality and
         integrity of all keying material MUST be maintained.</t>

					<t hangText="Confirm Cryptographic Algorithm Selection:"><vspace blankLines="1"/> The selection of the "best" cryptographic algorithms SHOULD be securely
         confirmed.  The mechanism SHOULD detect attempted roll-back
         attacks.</t>

					<t hangText="Uniquely Named Keys:"><vspace blankLines="1"/> Key management proposals require a robust key naming
         scheme, particularly where key caching is supported.  The key
         name provides a way to refer to a key in a protocol so that it
         is clear to all parties which key is being referenced.  Objects
         that cannot be named cannot be managed.  All keys MUST be
         uniquely named, and the key name MUST NOT directly or
         indirectly disclose the keying material.</t>

					<t hangText="Prevent the Domino Effect:"><vspace blankLines="1"/> Compromise of a single Client MUST NOT compromise keying material
         held by any other Client within the system, including session
         keys and long-term keys.  Likewise, compromise of a single
         Resource Server MUST NOT compromise keying material held by any
         other Resource Server within the system.  In the context of a key
         hierarchy, this means that the compromise of one node in the
         key hierarchy must not disclose the information necessary to
         compromise other branches in the key hierarchy.  Obviously, the
         compromise of the root of the key hierarchy will compromise all
         of the keys; however, a compromise in one branch MUST NOT
         result in the compromise of other branches.  There are many
         implications of this requirement; however, two implications
         deserve highlighting.  First, the scope of the keying material
         must be defined and understood by all parties that communicate
         with a party that holds that keying material.  Second, a party
         that holds keying material in a key hierarchy must not share
         that keying material with parties that are associated with
         other branches in the key hierarchy.         
					</t>
					<t hangText="Bind Key to its Context:"><vspace blankLines="1"/>  Keying material MUST be bound to the appropriate context.  The
         context includes the following.<list style="symbols"> 
							<t> The manner in which the keying material is expected to be
               used.</t>

							<t> The other parties that are expected to have access to the
               keying material.</t>

							<t> The expected lifetime of the keying material.  Lifetime
               of a child key SHOULD NOT be greater than the lifetime of
               its parent in the key hierarchy.</t>
						</list> 


         Any party with legitimate access to keying material can
         determine its context.  In addition, the protocol MUST ensure
         that all parties with legitimate access to keying material have
         the same context for the keying material.  This requires that
         the parties are properly identified and authenticated, so that
         all of the parties that have access to the keying material can
         be determined. The context will include the Client and the Resource Server identities in more
         than one form.</t>

					<t hangText="Authorization Restriction:"><vspace blankLines="1"/> If Client authorization is restricted, then the Client SHOULD be
         made aware of the restriction. </t>

					<t hangText="Client Identity Confidentiality:"><vspace blankLines="1"/> A Client has identity confidentiality when any party other than
   the Resource Server and the Authorization Server cannot sufficiently identify the Client within the
   anonymity set. In comparison to anonymity and pseudonymity, identity
   confidentiality is concerned with eavesdroppers and intermediaries. A key management protocol SHOULD provide this property.</t>

					<t hangText="Resource Owner Identity Confidentiality:"><vspace blankLines="1"/> Resource servers SHOULD be prevented from knowing the real or
      pseudonymous identity of the Resource Owner, since the Authorization Server
       is the only entity involved in verifying the Resource Owner's identity.</t>


					<t hangText="Collusion:"><vspace blankLines="1"/> Resource Servers that collude can be prevented from using information related to the Resource Owner to track the individual.  That is, two
      different Resource Servers can be prevented from determining that
      the same Resource Owner has authenticated to both of them.  This
      requires that each Authorization Server obtains different keying material as well as different access tokens
      with content that does not allow identification of the Resource Owner. </t>

					<t hangText="AS-to-RS Relationship Anonymity:"><vspace blankLines="1"/> This MAC Token security does not provide AAS-to-RS Relationship Anonymity since the Client has to inform the resource server about the Resource Server it wants to talk to. The Authorization Server needs to know how to encrypt the session key the Client and the Resource Server will be using.</t>
				</list>
			</t>

			<t>As an additional requirement a solution MUST enable support for channel bindings. The concept of channel binding, as defined in <xref target="RFC5056"/>, allows applications to establish that
   the two end-points of a secure channel at one network layer are the
   same as at a higher layer by binding authentication at the higher
   layer to the channel at the lower layer.</t>

			<t>There are performance concerns with the use of asymmetric cryptography. Although symmetric key cryptography offers better performance asymmetric cryptography offers additional security properties. A solution MUST therefore offer the capability to support both symmetric as well as asymmetric keys.</t>

			<t>There are threats that relate to the experience of the software developer as well as operational practices. Verifying the servers identity in TLS is discussed at length in <xref target="RFC6125"/>.</t>

		<t>A number of the threats listed in <xref target="threats"/> demand protection of the access token content and a standardized solution, in form of a JSON-based format, is available with the JSON Web Token (JWT) <xref target="I-D.ietf-oauth-json-web-token"/>. Hence, threat related to the protection of the access token itself are deferred to the <xref target="I-D.ietf-oauth-json-web-token"/>.</t>   

		
			
			
		</section> 


		<!-- ////////////////////////////////////////////////////////////////////////////////// -->

		<section title='Security Considerations'>

			<t>The purpose of this document is to provide use cases, requirements, and motivation for developing an OAuth security solution extending Bearer Tokens. As such, this document is only about security.</t>
		</section> 

		<!-- ////////////////////////////////////////////////////////////////////////////////// -->

		<section title='IANA Considerations'>

			<t>This document does not require actions by IANA.</t>
		</section> 

		<!-- ////////////////////////////////////////////////////////////////////////////////// -->

		<section title='Acknowledgments'>

			<t>This document is the result of conference calls late 2012/early 2013 and in design team conference calls February 2013 of the IETF OAuth working group. The following persons (in addition to the OAuth WG chairs, Hannes Tschofenig, and Derek Atkins) provided their input during these calls: Bill Mills, Justin Richer, Phil Hunt, Prateek Mishra, Mike Jones, George Fletcher, Leif Johansson, Lucy Lynch, John Bradley, Tony Nadalin, Klaas Wierenga, Thomas Hardjono, Brian Campbell</t>

			<t>In the appendix of this document we re-use content from <xref target="RFC4962"/> and the authors would like thank Russ Housely and Bernard Aboba for their work on RFC 4962.</t> 

		</section>

		<!-- ////////////////////////////////////////////////////////////////////////////////// -->

	</middle>

	<back>

		<references title='Normative References'>
			<?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml' ?>
			<?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.2045.xml' ?>
			<?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.2104.xml' ?>
			<?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.2616.xml' ?>
			<?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.2617.xml' ?>

			<?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.3986.xml' ?>

			<?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.5226.xml' ?>
			<?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.5246.xml' ?>

			<?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.6265.xml' ?>
			<?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.6749.xml' ?>

			<?rfc include='http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-httpbis-p1-messaging.xml' ?>
			<?rfc include='http://xml.resource.org/public/rfc/bibxml3/reference.I-D.tschofenig-oauth-audience.xml' ?>
			<?rfc include='http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-oauth-json-web-token.xml' ?>
			<?rfc include='http://xml.resource.org/public/rfc/bibxml3/reference.I-D.richer-oauth-introspection.xml' ?>
			<?rfc include='http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-jose-json-web-encryption.xml' ?>
			<?rfc include='http://xml.resource.org/public/rfc/bibxml3/reference.I-D.jones-oauth-proof-of-possession.xml' ?>
			<?rfc include='http://xml.resource.org/public/rfc/bibxml4/reference.W3C.REC-html401-19991224.xml' ?>
			
			<?rfc include='http://xml.resource.org/public/rfc/bibxml3/reference.I-D.richer-oauth-introspection.xml' ?>
			


		</references>

		<references title='Informative References'>
			<?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.4086.xml' ?>
			<?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.4120.xml' ?>
			<?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.4279.xml' ?>
			<?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.4962.xml' ?>

			<?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.5056.xml' ?>	  
			<?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.5849.xml' ?>
			<?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.5929.xml' ?>
			<?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.6819.xml' ?>
			
			

			<?rfc include='http://xml.resource.org/public/rfc/bibxml3/reference.I-D.hardjono-oauth-kerberos.xml' ?>


			<?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.6125.xml' ?>
			<?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.6750.xml' ?> 	   	  


			<reference anchor='NIST-FIPS-180-3'>
				<front>
					<title>Secure Hash Standard (SHS). FIPS PUB 180-3, October 2008</title>
					<author>
						<organization>National Institute of Standards and Technology</organization>
					</author>
					<date month="October" year="2008"/>
				</front>
				<format type='pdf' target='http://www.nist.gov/itl/upload/fips180-3_final.pdf' />
			</reference>


			<reference anchor="NIST800-63">
				<front>
					<title>NIST Special Publication 800-63-1, INFORMATION SECURITY</title>
					<author fullname="William E. Burr" initials="W." surname="Burr">
						<organization>NIST</organization>
					</author>
					<author fullname="Donna F. Dodson" initials="D." surname="Dodson">
						<organization>NIST</organization>
					</author>
					<author fullname="Ray A. Perlner" initials="R." surname="Perlner">
						<organization>NIST</organization>
					</author>
					<author fullname="W. Timothy Polk" initials="T." surname="Polk">
						<organization>NIST</organization>
					</author>
					<author fullname="Sarbari Gupta" initials="S." surname="Gupta">
						<organization>NIST</organization>
					</author>
					<author fullname="Emad A. Nabbus" initials="E." surname="Nabbus">
						<organization>NIST</organization>
					</author>
					<date month="December" year="2008"/>
				</front>
				<format target="http://csrc.nist.gov/publications/PubsDrafts.html#SP-800-63-Rev.%201" type="HTML"/>
			</reference>

		</references>


	</back>

</rfc>
